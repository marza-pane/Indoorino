
static  PyObject        *   obj_buffer      =nullptr;

PyObject  *     ipacket::packet2dict    (char * name)
{
    obj_buffer = PyDict_New();
    
    PyObject  * pyp_label  = PyUnicode_FromString(F2C(label()));
    PyObject  * pyp_name   = PyUnicode_FromString(name);
    PyObject  * pyp_command= PyLong_FromUnsignedLong(command());
    PyObject  * pyp_dsize  = PyLong_FromUnsignedLong(data_size());
    PyObject  * pyp_fsize  = PyLong_FromUnsignedLong(full_size());
    
    PyDict_SetItemString(obj_buffer, "label",        pyp_label);
    PyDict_SetItemString(obj_buffer, "name",         pyp_name);
    PyDict_SetItemString(obj_buffer, "command",      pyp_command);
    PyDict_SetItemString(obj_buffer, "data_size",    pyp_dsize);
    PyDict_SetItemString(obj_buffer, "full_size",    pyp_fsize);

    Py_XDECREF(pyp_label);
    Py_XDECREF(pyp_name);
    Py_XDECREF(pyp_command);
    Py_XDECREF(pyp_dsize);
    Py_XDECREF(pyp_fsize);
    
    PyObject * data=PyDict_New();
    
    packetmap_template pck;
    varmap_template    pvr;

    memcpy_P(&pck, _fptr, sizeof(pck));

    
    ibasize_t   increment=0;
    char        type_name[LEN_FIELD];
    
    for (ibavar_t i=0; i<pck.fields; i++)
    {       
        for(ibavar_t j=0; j<VARMAP_NUMBER; j++)
        {
            if (pck.var[i] == j)
            {
                memcpy(&pvr, &VarTable[j], sizeof(pvr));
                strcpy(type_name, pvr.name);

                switch (pvr.type)
                {
                    case 'c':
                    {
                        char buffer[pvr.size];
                        strcpy(buffer, _data + increment);
                        PyObject * pyp_buffer;
                        if (is_string_human(buffer))
                        {
                            pyp_buffer = PyUnicode_FromString(buffer);
                            PyDict_SetItemString(data, type_name ,pyp_buffer);
                        }
                        else
                        {
                            printf("ipacket2dict: Invalid string %s for %s", buffer, type_name);               
                            pyp_buffer = PyUnicode_FromString("");
                            PyDict_SetItemString(data, type_name ,pyp_buffer);
                        }
                        Py_XDECREF(pyp_buffer);
                        
                        break;
                    }
                    case 's':
                    {
                        uint8_t u8=0;
                        PyObject * pyp_u8 = PyLong_FromUnsignedLong(u8);
                        memcpy(&u8, _data + increment, sizeof(uint8_t));
                        PyDict_SetItemString(data, type_name ,PyLong_FromUnsignedLong(u8));
                        Py_XDECREF(pyp_u8);
                        break;
                    }
                    case 'l':
                    {
                        uint32_t u32=0;
                        PyObject * pyp_u32 = PyLong_FromUnsignedLong(u32);
                        memcpy(&u32, _data + increment, sizeof(uint32_t));
                        PyDict_SetItemString(data, type_name ,PyLong_FromUnsignedLong(u32));
                        Py_XDECREF(pyp_u32);
                        break;
                    }
                    default:
                    {
                        printf("ipacket2dict: Invalid type %c for %s", pvr.type, type_name);               
                    }
                }
                increment += pvr.size;
                break;
            }
        }
    }
    
    PyDict_SetItemString(obj_buffer, "data", data);
    Py_XDECREF(data);
//     Py_XDECREF(obj_buffer);
    return obj_buffer;
}


void            ipacket::dict2packet    (PyObject  * ptr)
{
    if (!PyDict_Check(ptr))
    {
        debug_mem("\nWARING:packet:dict2packet: object is not a dict()!");
        return;
    }
    
    packetmap_template pck;
    varmap_template    pvr;

    memcpy_P(&pck, _fptr, sizeof(pck));

    
    ibasize_t   increment=0;
    char        var_name[LEN_FIELD];
    
    for (ibavar_t i=0; i<pck.fields; i++)
    {       
        for(ibavar_t j=0; j<VARMAP_NUMBER; j++)
        {
            if (pck.var[i] == j)
            {
                memcpy(&pvr, &VarTable[j], sizeof(pvr));
                strcpy(var_name, pvr.name);
                
                debug_mem("\n\tpacket:dict2packet:found variable %s [%c : %d] ", var_name, pvr.type, pvr.size);
                
                PyObject * pyp_var_name = PyUnicode_FromString(var_name);
                
                if (PyDict_Contains(ptr, pyp_var_name))
                {
                    switch (pvr.type)
                    {
                        case 'c':
                        {
                            const char * p = PyUnicode_AsUTF8(PyDict_GetItemString(ptr, var_name));
                            if (is_string_human(p))
                            {
                                debug(" --> string : %s",p);
                                strcpy(_data + increment, p);               
//                                 strncpy(_data + increment, p, min((uint16_t)strlen(p), (uint16_t)SERIAL_TX_BUFFER_SIZE));               
                            }
                            else
                            {
                                error_io("\nWARNING:packet:dict2packet: invalid string for %s <%s>", var_name, p);
                            }
                            break;
                        }
                        case 's':
                        {
                            uint8_t u8 = PyLong_AsLong(PyDict_GetItemString(ptr, var_name));;
                            memcpy(_data + increment, &u8, sizeof(uint8_t));               
                            debug(" --> uint8_t : %d",u8);
                            break;
                        }
                        case 'l':
                        {
                            uint32_t u32 = PyLong_AsLong(PyDict_GetItemString(ptr, var_name));;
                            memcpy(_data + increment, &u32, sizeof(uint32_t));               
                            debug(" --> uint8_t : %d",u32);
                            break;
                        }
                        default:
                        {
                            break;
                        }
                    }
                    
                    increment += pvr.size;
                    break;
                }
                
                Py_XDECREF(pyp_var_name);
                
            }
        }
    }


//     if (is_dictkey(ptr, "name"))
//     {
//         const char * name=PyUnicode_AsUTF8(PyDict_GetItemString(ptr, "name"));
//         strcpy(_data->name(), name);
//     }
// 
//     if (is_dictkey(ptr, "nextprobe"))
//     {
//         *_data->nextprobe() = PyLong_AsLong(PyDict_GetItemString(ptr, "nextprobe"));
//     }
// 
//     if (is_dictkey(ptr, "probes"))
//     {
//         *_data->probes() = PyLong_AsLong(PyDict_GetItemString(ptr, "probes"));
//     }

}
